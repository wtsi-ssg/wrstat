/*******************************************************************************
 * Copyright (c) 2022 Genome Research Ltd.
 *
 * Author: Sendu Bala <sb10@sanger.ac.uk>
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

package pathsize

import (
	"bufio"
	"errors"
	"io"
	"strconv"
	"strings"
)

type ParseError string

func (e ParseError) Error() string { return "the provided data was not in size format: " + string(e) }

const (
	ErrBlankLine     = Error("the provided line had no information")
	pathsizeDataCols = 2
)

type pathsizeParserCallBack func(*PathSize)

// parsePathSizeLines will parse the given size file data (as generated by
// stat.SizeOperation()) and send *PathSize structs to your callback.
//
// Each *PathSize will correspond to a line from the size file. Your callback
// will receive exactly 1 *PathSize per line.
//
// Any issues with parsing the size file data will result in this method
// returning an error.
func parsePathSizeLines(data io.Reader, cb pathsizeParserCallBack) error {
	scanner := bufio.NewScanner(data)
	for scanner.Scan() {
		path, size, err := parsePathSizeLine(scanner.Text())
		if err != nil {
			if errors.Is(err, ErrBlankLine) {
				continue
			}

			return err
		}

		cb(&PathSize{Path: path, Size: size})
	}

	return scanner.Err()
}

// parsePathSizeLine parses a line of stat.SizeOperation() into a path and size.
//
// Returns an error if line didn't have the expected format.
func parsePathSizeLine(line string) (string, uint64, error) {
	parts, err := splitPathSizeLine(line)
	if err != nil {
		return "", 0, err
	}

	if parts[0] == "" {
		return "", 0, ErrBlankLine
	}

	size, err := strconv.ParseUint(parts[1], 10, 64)

	return parts[0], size, err
}

// splitPathSizeLine trims the \n from line and splits it in to 2 columns.
func splitPathSizeLine(line string) ([]string, error) {
	line = strings.TrimSuffix(line, "\n")

	parts := strings.Split(line, "\t")

	if len(parts) > pathsizeDataCols {
		// assume the filename had tabs in it
		size, path := parts[len(parts)-1], parts[:len(parts)-1]
		parts = []string{strings.Join(path, "\t"), size}
	}

	if len(parts) != pathsizeDataCols {
		return nil, ParseError(line)
	}

	return parts, nil
}
